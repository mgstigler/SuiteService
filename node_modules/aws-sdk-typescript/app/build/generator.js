/// <reference path="../../typings/tsd.d.ts" />
var fs = require("fs");
var handlebars = require("handlebars");
var AWSTypeGenerator = (function () {
    function AWSTypeGenerator() {
    }
    AWSTypeGenerator.prototype.fetchTemplate = function (name) {
        var templateSource = fs.readFileSync(__dirname + ("/../src/" + name + ".handlebars")).toString();
        return handlebars.compile(templateSource);
    };
    AWSTypeGenerator.prototype.generateServiceDefinitions = function (api) {
        var moduleTemplate = this.fetchTemplate("module");
        this.cleanShapes(api.descriptor);
        handlebars.registerHelper("camelCase", function (name) {
            return name.charAt(0).toLowerCase() + name.substring(1);
        });
        return moduleTemplate(api);
    };
    AWSTypeGenerator.prototype.generateMainModule = function (services) {
        var template = this.fetchTemplate('aws-sdk');
        return template({ services: services });
    };
    AWSTypeGenerator.prototype.getAlias = function (shape) {
        var alias = { name: shape.name, type: shape.type };
        var comments = [];
        if (shape.pattern) {
            comments.push("pattern: \"" + shape.pattern + "\"");
        }
        if (shape.max) {
            comments.push("max: " + shape.max);
        }
        if (shape.min) {
            comments.push("min: " + shape.min);
        }
        if (shape.type.match(/long|integer|timestamp|double|float/)) {
            alias.type = 'number';
        }
        else if (shape.type == 'map') {
            if (shape.value) {
                alias.type = "{[key:string]: " + shape.value.shape + "}";
            }
            else {
                shape.type == 'any';
                comments.push('type: map');
            }
        }
        else if (shape.type == 'blob') {
            alias.type = 'any';
            comments.push('type: ' + 'blob');
        }
        else if (shape.type == 'list') {
            alias.type = shape.member.shape + '[]';
        }
        if (comments.length) {
            alias.comment = comments.join(', ');
        }
        return alias;
    };
    AWSTypeGenerator.prototype.getStructure = function (shape) {
        Object.keys(shape.members).forEach(function (k) {
            shape.members[k].required = "?";
        });
        if (shape.required) {
            shape.required.forEach(function (k) {
                shape.members[k].required = "";
            });
        }
        return shape;
    };
    AWSTypeGenerator.prototype.cleanShapes = function (descriptor) {
        //set the name
        Object.keys(descriptor.shapes)
            .forEach(function (name) { return descriptor.shapes[name].name = name; });
        //get aliases
        descriptor.aliases = Object.keys(descriptor.shapes)
            .map(function (name) { return descriptor.shapes[name]; })
            .filter(function (shape) { return shape.type != 'structure'; })
            .filter(function (shape) { return shape.name != 'string' && shape.name != 'boolean' && shape.name != 'number'; }) //exclude builtins
            .map(this.getAlias);
        //Get structures
        descriptor.structures = Object.keys(descriptor.shapes)
            .map(function (name) { return descriptor.shapes[name]; })
            .filter(function (shape) { return shape.type == 'structure'; })
            .map(this.getStructure);
    };
    return AWSTypeGenerator;
})();
exports.AWSTypeGenerator = AWSTypeGenerator;
