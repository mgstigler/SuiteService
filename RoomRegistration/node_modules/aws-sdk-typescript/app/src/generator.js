"use strict";
/// <reference path="../../typings/tsd.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const handlebars = require("handlebars");
class AWSTypeGenerator {
    fetchTemplate(name) {
        var templateSource = fs.readFileSync(__dirname + `/../src/${name}.handlebars`).toString();
        return handlebars.compile(templateSource);
    }
    generateServiceDefinitions(api) {
        var moduleTemplate = this.fetchTemplate("module");
        this.cleanShapes(api.descriptor);
        handlebars.registerHelper("camelCase", function (name) {
            return name.charAt(0).toLowerCase() + name.substring(1);
        });
        return moduleTemplate(api);
    }
    generateMainModule(services) {
        var template = this.fetchTemplate('aws-sdk');
        return template({ services: services });
    }
    getAlias(shape) {
        var alias = { name: shape.name, type: shape.type };
        var comments = [];
        if (shape.pattern) {
            comments.push(`pattern: "${shape.pattern}"`);
        }
        if (shape.max) {
            comments.push(`max: ${shape.max}`);
        }
        if (shape.min) {
            comments.push(`min: ${shape.min}`);
        }
        if (shape.type.match(/long|integer|timestamp|double|float/)) {
            alias.type = 'number';
        }
        else if (shape.type == 'map') {
            if (shape.value) {
                alias.type = `{[key:string]: ${shape.value.shape}}`;
            }
            else {
                shape.type == 'any';
                comments.push('type: map');
            }
        }
        else if (shape.type == 'blob') {
            alias.type = 'any';
            comments.push('type: ' + 'blob');
        }
        else if (shape.type == 'list') {
            alias.type = shape.member.shape + '[]';
        }
        if (comments.length) {
            alias.comment = comments.join(', ');
        }
        return alias;
    }
    getStructure(shape) {
        Object.keys(shape.members).forEach(function (k) {
            shape.members[k].required = "?";
        });
        if (shape.required) {
            shape.required.forEach(function (k) {
                shape.members[k].required = "";
            });
        }
        return shape;
    }
    cleanShapes(descriptor) {
        //set the name
        Object.keys(descriptor.shapes)
            .forEach(name => descriptor.shapes[name].name = name);
        //get aliases
        descriptor.aliases = Object.keys(descriptor.shapes)
            .map(name => descriptor.shapes[name])
            .filter(shape => shape.type != 'structure')
            .filter(shape => shape.name != 'string' && shape.name != 'boolean' && shape.name != 'number') //exclude builtins
            .map(this.getAlias);
        //Get structures
        descriptor.structures = Object.keys(descriptor.shapes)
            .map(name => descriptor.shapes[name])
            .filter(shape => shape.type == 'structure')
            .map(this.getStructure);
    }
}
exports.AWSTypeGenerator = AWSTypeGenerator;
//# sourceMappingURL=generator.js.map